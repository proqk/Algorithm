#include <iostream>
#include <algorithm>
using namespace std;
int dp[10001]; //합이 i일 때의 최소 동전 개수
int a[10001];
int main() {
	int n, k;
	cin >> n >> k;

	for (int i = 1; i <= n; i++) {
		cin >> a[i];
	}
	for (int i = 1; i <= k; i++) dp[i] = 99999; //최대 동전 개수
	dp[0] = 0;

	for (int i = 1; i <= n; i++) {
		for (int j = a[i]; j <= k; j++) {
			//현재 금액만 사용했을 때 최소 몇 개의 동전이 필요한가 하나씩 본다
			//1원 쓸 때는 1~15원까지 각 개수만큼 사용해서 1,2,3..15까지
			//다음 5원 쓸 때는 1~4원까지는 1원을 쓴 그대로, 5원은 5원 1개로 만들 수 있으니까 1이 되고,
			//6,7,8,9까지는 5+x개의 1원을 쓰니까 각각 2,3,4,5개를 사용해서 만들 수 있다
			//이 때 이전에 1원 계산했던 값에서+5원을 하면 5원 1개+1원 x개로 만든 값이 나오니까
			//j-a[i](1원 x로 만든 값)+1(5원 1개 더한 값)이 식이다
			//다음 10은 5원 2개로 되니까 2가 되고, 11~14는 2개+x개니까 아까와 같이 갱신한다
			//그렇게 a[i]배열인 1,5,12 세 개에 대해서 1~k까지의 값들을 만들 수 있는 최소 동전 수를 전부 구한다

			dp[j] = min(dp[j], dp[j - a[i]] + 1); //현재까지의 최소값vs이전에 만든 최소값+현재 값을 더함
		}
	}
	if (dp[k] != 99999) cout << dp[k];
	else cout << -1;
}
